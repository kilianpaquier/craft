package generate_test

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	"github.com/samber/lo"
	"github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/kilianpaquier/craft/pkg/craft"
	cfs "github.com/kilianpaquier/craft/pkg/fs"
	testfs "github.com/kilianpaquier/craft/pkg/fs/tests"
	"github.com/kilianpaquier/craft/pkg/generate"
)

func TestIsGenerated(t *testing.T) {
	t.Run("generated_doesnt_exist", func(t *testing.T) {
		// Arrange
		dest := filepath.Join(t.TempDir(), "invalid.txt")

		// Act
		generated := generate.IsGenerated(dest)

		// Assert
		assert.True(t, generated)
	})

	t.Run("not_generated_file", func(t *testing.T) {
		// Arrange
		dest := filepath.Join(t.TempDir(), "file.txt")
		err := os.WriteFile(dest, []byte("not generated"), cfs.RwRR)
		require.NoError(t, err)

		// Act
		generated := generate.IsGenerated(dest)

		// Assert
		assert.False(t, generated)
	})

	t.Run("generated_folder", func(t *testing.T) {
		// Arrange
		dest := filepath.Join(t.TempDir(), "folder")
		require.NoError(t, os.Mkdir(dest, cfs.RwxRxRxRx))

		// Act
		generated := generate.IsGenerated(dest)

		// Assert
		assert.True(t, generated)
	})

	t.Run("generated_no_lines", func(t *testing.T) {
		// Arrange
		dest := filepath.Join(t.TempDir(), "file.txt")
		file, err := os.Create(dest)
		require.NoError(t, err)
		t.Cleanup(func() { assert.NoError(t, file.Close()) })

		// Act
		generated := generate.IsGenerated(dest)

		// Assert
		assert.True(t, generated)
	})

	t.Run("generated_first_line", func(t *testing.T) {
		// Arrange
		dest := filepath.Join(t.TempDir(), "file.txt")
		err := os.WriteFile(dest, []byte("Code generated by craft; DO NOT EDIT."), cfs.RwRR)
		require.NoError(t, err)

		// Act
		generated := generate.IsGenerated(dest)

		// Assert
		assert.True(t, generated)
	})

	t.Run("generated_second_line", func(t *testing.T) {
		// Arrange
		dest := filepath.Join(t.TempDir(), "file.txt")
		err := os.WriteFile(dest, []byte("\nCode generated by craft; DO NOT EDIT."), cfs.RwRR)
		require.NoError(t, err)

		// Act
		generated := generate.IsGenerated(dest)

		// Assert
		assert.True(t, generated)
	})
}

func TestExec_Generic(t *testing.T) {
	ctx := context.Background()
	log := logrus.WithContext(ctx)

	assertdir := filepath.Join("..", "..", "testdata", "generic")
	srcdir := "templates"
	exec := generate.DefaultExec("lang_generic")

	setup := func(metadata generate.Metadata) (generate.Metadata, generate.ExecOpts) {
		metadata.ProjectHost = "example.com"
		metadata.ProjectName = "craft"
		metadata.ProjectPath = "kilianpaquier/craft"

		return metadata, generate.ExecOpts{
			FileHandlers: lo.Map(generate.MetaHandlers(), func(handler generate.MetaHandler, _ int) generate.FileHandler {
				return handler(metadata)
			}),
			EndDelim:   ">>",
			StartDelim: "<<",
			ForceAll:   true,
		}
	}

	t.Run("success_github", func(t *testing.T) {
		// Arrange
		destdir := t.TempDir()
		assertdir := filepath.Join(assertdir, "success_github")

		metadata, opts := setup(generate.Metadata{
			Configuration: craft.Configuration{
				Maintainers: []craft.Maintainer{{Name: "maintainer name"}},
				CI: &craft.CI{
					Name:    craft.Github,
					Options: craft.CIOptions(),
					Release: craft.Release{Auto: true, Backmerge: true, Mode: craft.GithubToken},
				},
				Platform: craft.Github,
			},
		})

		// Act
		err := exec(ctx, log, cfs.OS(), srcdir, destdir, metadata, opts)

		// Assert
		assert.NoError(t, err)
		assert.NoError(t, testfs.EqualDirs(assertdir, destdir))
	})

	t.Run("success_gitlab", func(t *testing.T) {
		// Arrange
		destdir := t.TempDir()
		assertdir := filepath.Join(assertdir, "success_gitlab")

		metadata, opts := setup(generate.Metadata{
			Configuration: craft.Configuration{
				CI: &craft.CI{
					Name:    craft.Gitlab,
					Options: craft.CIOptions(),
					Release: craft.Release{Auto: true, Backmerge: true},
				},
				Maintainers: []craft.Maintainer{{Name: "maintainer name"}},
				Platform:    craft.Gitlab,
			},
		})

		// Act
		err := exec(ctx, log, cfs.OS(), srcdir, destdir, metadata, opts)

		// Assert
		assert.NoError(t, err)
		assert.NoError(t, testfs.EqualDirs(assertdir, destdir))
	})
}

func TestExec_Golang(t *testing.T) {
	ctx := context.Background()
	log := logrus.WithContext(ctx)

	assertdir := filepath.Join("..", "..", "testdata", "golang")
	srcdir := "templates"
	golang := generate.DefaultExec("lang_golang")

	setup := func(metadata generate.Metadata) (generate.Metadata, generate.ExecOpts) {
		metadata.Languages = map[string]any{"golang": generate.Gomod{LangVersion: "1.22"}}
		metadata.ProjectHost = "example.com"
		metadata.ProjectName = "craft"
		metadata.ProjectPath = "kilianpaquier/craft"

		return metadata, generate.ExecOpts{
			FileHandlers: lo.Map(generate.MetaHandlers(), func(handler generate.MetaHandler, _ int) generate.FileHandler {
				return handler(metadata)
			}),
			EndDelim:   ">>",
			StartDelim: "<<",
			ForceAll:   true,
		}
	}

	t.Run("success_binaries", func(t *testing.T) {
		// Arrange
		destdir := t.TempDir()
		assertdir := filepath.Join(assertdir, "success_binaries")

		metadata, opts := setup(generate.Metadata{
			Binaries: 4,
			Clis:     map[string]struct{}{"cli-name": {}},
			Configuration: craft.Configuration{
				Docker:      &craft.Docker{Port: lo.ToPtr(uint16(5000))},
				License:     lo.ToPtr("mit"),
				Maintainers: []craft.Maintainer{{Name: "maintainer name"}},
			},
			Crons:   map[string]struct{}{"cron-name": {}},
			Jobs:    map[string]struct{}{"job-name": {}},
			Workers: map[string]struct{}{"worker-name": {}},
		})

		// Act
		err := golang(ctx, log, cfs.OS(), srcdir, destdir, metadata, opts)

		// Assert
		assert.NoError(t, err)
		assert.NoError(t, testfs.EqualDirs(assertdir, destdir))
	})

	t.Run("success_no_binaries", func(t *testing.T) {
		// Arrange
		destdir := t.TempDir()
		assertdir := filepath.Join(assertdir, "success_no_binaries")

		metadata, opts := setup(generate.Metadata{
			Configuration: craft.Configuration{
				Maintainers: []craft.Maintainer{{Name: "maintainer name"}},
			},
		})

		// Act
		err := golang(ctx, log, cfs.OS(), srcdir, destdir, metadata, opts)

		// Assert
		assert.NoError(t, err)
		assert.NoError(t, testfs.EqualDirs(assertdir, destdir))
	})

	t.Run("success_one_binary_docker", func(t *testing.T) {
		// Arrange
		destdir := t.TempDir()
		assertdir := filepath.Join(assertdir, "success_one_binary_docker")

		metadata, opts := setup(generate.Metadata{
			Binaries: 1,
			Clis:     map[string]struct{}{"cli-name": {}},
			Configuration: craft.Configuration{
				Docker:       &craft.Docker{},
				Maintainers:  []craft.Maintainer{{Name: "maintainer name"}},
				NoGoreleaser: true,
				NoMakefile:   true,
			},
		})

		// Act
		err := golang(ctx, log, cfs.OS(), srcdir, destdir, metadata, opts)

		// Assert
		assert.NoError(t, err)
		assert.NoError(t, testfs.EqualDirs(assertdir, destdir))
	})

	t.Run("success_options_binaries_github", func(t *testing.T) {
		// Arrange
		destdir := t.TempDir()
		assertdir := filepath.Join(assertdir, "success_options_binaries_github")

		metadata, opts := setup(generate.Metadata{
			Binaries: 4,
			Clis:     map[string]struct{}{"cli-name": {}},
			Configuration: craft.Configuration{
				CI: &craft.CI{
					Name:    craft.Github,
					Options: craft.CIOptions(),
					Release: craft.Release{Auto: true, Backmerge: true, Mode: craft.PersonalToken},
				},
				License:      lo.ToPtr("mit"),
				Maintainers:  []craft.Maintainer{{Name: "maintainer name"}},
				NoGoreleaser: true,
				Platform:     craft.Github,
			},
			Crons:   map[string]struct{}{"cron-name": {}},
			Jobs:    map[string]struct{}{"job-name": {}},
			Workers: map[string]struct{}{"worker-name": {}},
		})

		// Act
		err := golang(ctx, log, cfs.OS(), srcdir, destdir, metadata, opts)

		// Assert
		assert.NoError(t, err)
		assert.NoError(t, testfs.EqualDirs(assertdir, destdir))
	})

	t.Run("success_options_binaries_gitlab", func(t *testing.T) {
		// Arrange
		destdir := t.TempDir()
		assertdir := filepath.Join(assertdir, "success_options_binaries_gitlab")

		metadata, opts := setup(generate.Metadata{
			Binaries: 4,
			Clis:     map[string]struct{}{"cli-name": {}},
			Configuration: craft.Configuration{
				CI: &craft.CI{
					Name:    craft.Gitlab,
					Options: craft.CIOptions(),
					Release: craft.Release{Auto: true, Backmerge: true},
				},
				License:      lo.ToPtr("mit"),
				Maintainers:  []craft.Maintainer{{Name: "maintainer name"}},
				NoGoreleaser: true,
				Platform:     craft.Gitlab,
			},
			Crons:   map[string]struct{}{"cron-name": {}},
			Jobs:    map[string]struct{}{"job-name": {}},
			Workers: map[string]struct{}{"worker-name": {}},
		})

		// Act
		err := golang(ctx, log, cfs.OS(), srcdir, destdir, metadata, opts)

		// Assert
		assert.NoError(t, err)
		assert.NoError(t, testfs.EqualDirs(assertdir, destdir))
	})
}

func TestExec_Hugo(t *testing.T) {
	ctx := context.Background()
	log := logrus.WithContext(ctx)

	hugo := generate.DefaultExec("lang_hugo")
	assertdir := filepath.Join("..", "..", "testdata", "hugo")
	srcdir := "templates"

	setup := func(metadata generate.Metadata) (generate.Metadata, generate.ExecOpts) {
		metadata.Languages = map[string]any{"hugo": generate.Gomod{LangVersion: "1.22"}}
		metadata.ProjectHost = "example.com"
		metadata.ProjectName = "craft"
		metadata.ProjectPath = "kilianpaquier/craft"

		return metadata, generate.ExecOpts{
			FileHandlers: lo.Map(generate.MetaHandlers(), func(handler generate.MetaHandler, _ int) generate.FileHandler {
				return handler(metadata)
			}),
			EndDelim:   ">>",
			StartDelim: "<<",
			ForceAll:   true,
		}
	}

	t.Run("success_github", func(t *testing.T) {
		// Arrange
		destdir := t.TempDir()
		assertdir := filepath.Join(assertdir, "success_github")

		metadata, opts := setup(generate.Metadata{
			Configuration: craft.Configuration{
				CI: &craft.CI{
					Name:    craft.Github,
					Options: craft.CIOptions(),
					Release: craft.Release{Auto: true, Backmerge: true, Mode: craft.GithubToken},
				},
				License:     lo.ToPtr("mit"),
				Maintainers: []craft.Maintainer{{Name: "maintainer name"}},
				Platform:    craft.Github,
			},
		})

		// Act
		err := hugo(ctx, log, cfs.OS(), srcdir, destdir, metadata, opts)

		// Assert
		assert.NoError(t, err)
		assert.NoError(t, testfs.EqualDirs(assertdir, destdir))
	})

	t.Run("success_gitlab", func(t *testing.T) {
		// Arrange
		destdir := t.TempDir()
		assertdir := filepath.Join(assertdir, "success_gitlab")

		metadata, opts := setup(generate.Metadata{
			Configuration: craft.Configuration{
				CI: &craft.CI{
					Name:    craft.Gitlab,
					Options: craft.CIOptions(),
					Release: craft.Release{Auto: true, Backmerge: true},
				},
				License:     lo.ToPtr("mit"),
				Maintainers: []craft.Maintainer{{Name: "maintainer name"}},
				Platform:    craft.Gitlab,
			},
		})

		// Act
		err := hugo(ctx, log, cfs.OS(), srcdir, destdir, metadata, opts)

		// Assert
		assert.NoError(t, err)
		assert.NoError(t, testfs.EqualDirs(assertdir, destdir))
	})
}

func TestExec_Nodejs(t *testing.T) {
	ctx := context.Background()
	log := logrus.WithContext(ctx)

	nodejs := generate.DefaultExec("lang_nodejs")
	assertdir := filepath.Join("..", "..", "testdata", "nodejs")
	srcdir := "templates"

	setup := func(metadata generate.Metadata) (generate.Metadata, generate.ExecOpts) {
		metadata.ProjectHost = "example.com"
		metadata.ProjectName = "craft"
		metadata.ProjectPath = "kilianpaquier/craft"

		return metadata, generate.ExecOpts{
			FileHandlers: lo.Map(generate.MetaHandlers(), func(handler generate.MetaHandler, _ int) generate.FileHandler {
				return handler(metadata)
			}),
			EndDelim:   ">>",
			StartDelim: "<<",
			ForceAll:   true,
		}
	}

	t.Run("success_github", func(t *testing.T) {
		// Arrange
		destdir := t.TempDir()
		assertdir := filepath.Join(assertdir, "success_github")

		metadata, opts := setup(generate.Metadata{
			Configuration: craft.Configuration{
				CI: &craft.CI{
					Name:    craft.Github,
					Release: craft.Release{Disable: true},
				},
				Maintainers: []craft.Maintainer{{Name: "maintainer name"}},
				NoMakefile:  true,
				Platform:    craft.Github,
			},
			Languages: map[string]any{
				"nodejs": generate.PackageJSON{
					PackageManager: "yarn@2.4.3",
				},
			},
		})

		// Act
		err := nodejs(ctx, log, cfs.OS(), srcdir, destdir, metadata, opts)

		// Assert
		assert.NoError(t, err)
		assert.NoError(t, testfs.EqualDirs(assertdir, destdir))
	})

	t.Run("success_docker_github", func(t *testing.T) {
		// Arrange
		destdir := t.TempDir()
		assertdir := filepath.Join(assertdir, "success_docker_github")

		metadata, opts := setup(generate.Metadata{
			Binaries: 1,
			Configuration: craft.Configuration{
				CI: &craft.CI{
					Name:    craft.Github,
					Release: craft.Release{Mode: craft.PersonalToken},
				},
				Docker:      &craft.Docker{},
				Maintainers: []craft.Maintainer{{Name: "maintainer name"}},
				NoMakefile:  true,
				Platform:    craft.Github,
			},
			Languages: map[string]any{
				"nodejs": generate.PackageJSON{
					PackageManager: "pnpm@8.0.0",
					Private:        true,
				},
			},
		})

		// Act
		err := nodejs(ctx, log, cfs.OS(), srcdir, destdir, metadata, opts)

		// Assert
		assert.NoError(t, err)
		assert.NoError(t, testfs.EqualDirs(assertdir, destdir))
	})

	t.Run("success_gitlab", func(t *testing.T) {
		// Arrange
		destdir := t.TempDir()
		assertdir := filepath.Join(assertdir, "success_gitlab")

		metadata, opts := setup(generate.Metadata{
			Binaries: 1,
			Configuration: craft.Configuration{
				CI: &craft.CI{
					Name:    craft.Gitlab,
					Release: craft.Release{Disable: true},
				},
				Maintainers: []craft.Maintainer{{Name: "maintainer name"}},
				NoMakefile:  true,
				Platform:    craft.Gitlab,
			},
			Languages: map[string]any{
				"nodejs": generate.PackageJSON{
					PackageManager: "yarn@2.4.3",
				},
			},
		})

		// Act
		err := nodejs(ctx, log, cfs.OS(), srcdir, destdir, metadata, opts)

		// Assert
		assert.NoError(t, err)
		assert.NoError(t, testfs.EqualDirs(assertdir, destdir))
	})

	t.Run("success_docker_gitlab", func(t *testing.T) {
		// Arrange
		destdir := t.TempDir()
		assertdir := filepath.Join(assertdir, "success_docker_gitlab")

		metadata, opts := setup(generate.Metadata{
			Binaries: 1,
			Configuration: craft.Configuration{
				CI:          &craft.CI{Name: craft.Gitlab},
				Docker:      &craft.Docker{},
				Maintainers: []craft.Maintainer{{Name: "maintainer name"}},
				NoMakefile:  true,
				Platform:    craft.Gitlab,
			},
			Languages: map[string]any{
				"nodejs": generate.PackageJSON{
					PackageManager: "pnpm@8.0.0",
					Private:        true,
				},
			},
		})

		// Act
		err := nodejs(ctx, log, cfs.OS(), srcdir, destdir, metadata, opts)

		// Assert
		assert.NoError(t, err)
		assert.NoError(t, testfs.EqualDirs(assertdir, destdir))
	})

	t.Run("success_options_github", func(t *testing.T) {
		// Arrange
		destdir := t.TempDir()
		assertdir := filepath.Join(assertdir, "success_options_github")

		metadata, opts := setup(generate.Metadata{
			Configuration: craft.Configuration{
				CI: &craft.CI{
					Name:    craft.Github,
					Options: craft.CIOptions(),
					Release: craft.Release{Auto: true, Backmerge: true, Mode: craft.GithubApps},
				},
				License:     lo.ToPtr("mit"),
				Maintainers: []craft.Maintainer{{Name: "maintainer name"}},
				NoMakefile:  true,
				Platform:    craft.Github,
			},
			Languages: map[string]any{
				"nodejs": generate.PackageJSON{
					PackageManager: "bun@1.1.6",
				},
			},
		})

		// Act
		err := nodejs(ctx, log, cfs.OS(), srcdir, destdir, metadata, opts)

		// Assert
		assert.NoError(t, err)
		assert.NoError(t, testfs.EqualDirs(assertdir, destdir))
	})

	t.Run("success_options_gitlab", func(t *testing.T) {
		// Arrange
		destdir := t.TempDir()
		assertdir := filepath.Join(assertdir, "success_options_gitlab")

		metadata, opts := setup(generate.Metadata{
			Configuration: craft.Configuration{
				CI: &craft.CI{
					Name:    craft.Gitlab,
					Options: craft.CIOptions(),
					Release: craft.Release{Auto: true, Backmerge: true},
				},
				License:     lo.ToPtr("mit"),
				Maintainers: []craft.Maintainer{{Name: "maintainer name"}},
				NoMakefile:  true,
				Platform:    craft.Gitlab,
			},
			Languages: map[string]any{
				"nodejs": generate.PackageJSON{
					PackageManager: "bun@1.1.6",
				},
			},
		})

		// Act
		err := nodejs(ctx, log, cfs.OS(), srcdir, destdir, metadata, opts)

		// Assert
		assert.NoError(t, err)
		assert.NoError(t, testfs.EqualDirs(assertdir, destdir))
	})
}
