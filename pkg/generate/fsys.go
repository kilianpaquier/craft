package generate

import (
	"context"
	"errors"
	"fmt"
	"io/fs"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"slices"
	"strings"
	"text/template"

	"github.com/Masterminds/sprig/v3"
	"github.com/samber/lo"

	"github.com/kilianpaquier/craft/pkg/craft"
	cfs "github.com/kilianpaquier/craft/pkg/fs"
	"github.com/kilianpaquier/craft/pkg/logger"
	"github.com/kilianpaquier/craft/pkg/templating"
)

var (
	errDelete = errors.New("file deletion")
	errExist  = errors.New("file already exists")
)

// generated is the regexp for generated files.
var generated = regexp.MustCompile(`Code generated by [a-z-_0-9\ ]+; DO NOT EDIT\.`)

// IsGenerated returns truthy if input destination is a generated file.
func IsGenerated(dest string) bool {
	// retrieve file content, if there's an error, generation to make
	content, err := os.ReadFile(dest)
	if err != nil {
		return true
	}

	// special case (shouldn't happen) where the destination has been replaced with an empty file
	if len(content) == 0 {
		return true
	}
	lines := strings.Split(string(content), "\n")

	// check first line for generated regexp
	if len(lines) >= 1 && generated.MatchString(lines[0]) {
		return true
	}

	// check second line for generated regexp
	if len(lines) >= 2 && generated.MatchString(lines[1]) {
		return true
	}
	return false
}

// DefaultExec is a simplified function returning a basic Exec for an input template folder name.
func DefaultExec(name string) Exec {
	return func(_ context.Context, log logger.Logger, fsys cfs.FS, srcdir, destdir string, metadata Metadata, opts ExecOpts) error {
		return handleDir(log, fsys, srcdir, destdir, metadata, name, opts)
	}
}

// handleDir walks over input srcdir and apply template of every src entry into destdir.
func handleDir(log logger.Logger, fsys cfs.FS, srcdir, destdir string, data any, name string, opts ExecOpts) error { // nolint:revive
	// read source directory
	entries, err := fsys.ReadDir(srcdir)
	if err != nil {
		return fmt.Errorf("read directory: %w", err)
	}

	errs := lo.Map(entries, func(entry fs.DirEntry, _ int) error {
		src := path.Join(srcdir, entry.Name())
		dest := filepath.Join(destdir, entry.Name())

		if entry.IsDir() {
			// apply generation at root if the folder name is the dir generate name
			if entry.Name() == name {
				return handleDir(log, fsys, src, destdir, data, name, opts)
			}

			// apply templates on subdirs not being the reserved ones for languages
			if !strings.HasPrefix(entry.Name(), "lang_") {
				return handleDir(log, fsys, src, dest, data, name, opts)
			}

			return nil
		}

		// don't template files without .tmpl extension
		if !strings.HasSuffix(src, craft.TmplExtension) {
			return nil
		}
		dest = strings.TrimSuffix(dest, craft.TmplExtension)

		err := handleFile(fsys, src, dest, data, opts)
		if err == nil {
			return nil
		}
		if errors.Is(err, errDelete) {
			log.Warn("failed to delete '%s': %s", entry.Name(), err.Error())
			return nil
		}
		if errors.Is(err, errExist) {
			log.Infof("not copying '%s' since it already exists", dest)
			return nil
		}
		return err
	})
	return errors.Join(errs...)
}

// handleFile is a private function used to handle a specific file entry
// during iterative loops over folders and subfolders.
func handleFile(fsys cfs.FS, src, dest string, data any, opts ExecOpts) error {
	filename := filepath.Base(dest)

	// verify that file matches generation rules
	generate := opts.ForceAll || IsGenerated(dest) || slices.Contains(opts.Force, filename)
	singleGeneration := filename == craft.File && cfs.Exists(dest)
	if !generate || singleGeneration {
		return errExist
	}

	// check if filename matches an optional file
	for _, handler := range opts.FileHandlers {
		ok, apply := handler(src, dest, filename)
		if !ok {
			// don't do anything since the handler is not the right one for this file
			continue
		}
		if apply {
			// break loop since optional file was found
			break
		}

		// handle optional file deletion
		if err := os.RemoveAll(dest); err != nil && !errors.Is(err, fs.ErrNotExist) {
			return fmt.Errorf("remove file '%s': %w: %w", filename, errDelete, err)
		}
		return nil
	}

	tmpl, err := template.New(filepath.Base(src)).
		Funcs(sprig.FuncMap()).
		Funcs(templating.FuncMap()).
		Delims(opts.StartDelim, opts.EndDelim).
		ParseFS(fsys, src)
	if err != nil {
		return fmt.Errorf("parse template file: %w", err)
	}
	return templating.Execute(tmpl, data, dest)
}
